# Bunker's unit test functions.  See prototypes for help.  This file also sets
# up some variables (see end).  This design is based on boost's cmake test
# functions.
#
# These functions use wine to run tests on unix when cross-compiling for
# windows.
#
# Define the list variable BTEST_WINE_DLLPATHS to say where the dlls are for
# wine to searh for.  Otherwise you need to copy them to the test directories
# or configure wine to search for them using the PATH *from within wine*.
#
#######################
# FUNCTION: btest_add()
#
# Make a test with the target name name_test.  Note that if you are depending
# on a top level target, you should use add_dependencies on $name_test instead
# of using DEPENDS -- that's just for files.
#
# Details:
#
# btest_add(
#   <name | NAME name>
#   <source_list | SOURCES source...>
#   [ARGS arg... ]
#   [CPPDEFS define...]
#   [CFLAGS compile_flag...]
#   [LDFLAGS link_flag...]
#   [LIBS link_name...]
#   [DEPENDS depend...]
#   [XFAIL]
# )
#
############################
# FUNCTION: btest_add_ruby()
#
# Add a test which is generated by ruby.  All params are as btest_add() except
# GENERATOR_ARGS which is given to the ruby_file as its arguments.  Tests are
# automatically placed in a subdirectory of the binary dir which is removed
# with make clean.  SCRIPT_DEPENDS is to add more dependencies to the ruby
# target.
#
# Dependencies are also grepped based on "require '$file'" where when $file
# exists.
#
# Details:
#
# btest_add_ruby(
#   name
#   ruby_input
#   [GENERATOR_ARGS arg...]
#   [ARGS arg...]
#   [CPPDEFS define...]
#   [CFLAGS compile_flag...]
#   [LDFLAGS link_flag...]
#   [LIBS link_name...]
#   [DEPENDS depend...]
#   [SCRIPT_DEPENDS depend...]
#   [XFAIL]
# )


include("${CMAKE_SOURCE_DIR}/build-aux/butil.cmake")

message(STATUS "Setting up unit test functions.")

if (WIN32 AND CMAKE_CROSSCOMPILING AND CMAKE_HOST_UNIX)
  find_program(WINE_EXE wine)
  mark_as_advanced(WINE_EXE)
  if (WINE_EXE)
    message(STATUS "Wine will be used for cross-compiled unit tests: ${WINE_EXE}")
  else()
    message(STATUS "Wine cannot be found.  Unit tests may fail.")
  endif()

  set(
    BTEST_WINE_DLLPATHS "" CACHE STRING
    "Extra paths (seperate with semic) where dlls for wine are - rpath hack, basically."
  )
  mark_as_advanced(BTEST_WINE_DLLPATHS)

  set(btest_envpath_bin "setenvpath")
  add_executable(${btest_envpath_bin} "${CMAKE_SOURCE_DIR}/build-aux/setenvpath.c")

  set(btest_envpath_exe ${CMAKE_BINARY_DIR}/${btest_envpath_bin}${CMAKE_EXECUTABLE_SUFFIX})

  foreach (dir ${BTEST_WINE_DLLPATHS})
    if (NOT IS_DIRECTORY "${dir}")
      message(FATAL_ERROR "Directory in BTEST_WINE_DLLPATHS does not exist: ${dir}")
    endif()

    list(APPEND btest_envpath_args "-p")
    list(APPEND btest_envpath_args "${dir}")
  endforeach()

  # Finally set the prefix we will use to run test.
  # TODO: it would be much better if we could depend on envpath_bin inside of the
  #       unit tests but I'm having trouble making that actually work so for now
  #       we just assume it is ok to build with ALL..
  if (BTEST_WINE_DLLPATHS)
    set(BTEST_EMULATOR_PF    "${WINE_EXE};${btest_envpath_exe};${btest_envpath_args}")
  else()
    set(BTEST_EMULATOR_PF    "${WINE_EXE}")
  endif()
endif()

set(BTEST_ADD_RUBY_DIR "${CMAKE_BINARY_DIR}/ruby_tests")

# we are not allowed to append to the binary dir aparently.
set_property(
  DIRECTORY APPEND
  PROPERTY "ADDITIONAL_MAKE_CLEAN_FILES"
  "${BTEST_ADD_RUBY_DIR}"
)

find_program(RUBY_EXE ruby)
if (NOT RUBY_EXE)
  find_program(RUBY_EXE ruby1.8)
endif()

# Basic add of a test.
function(btest_add)
  butil_parse_args(
    "NAME;ARGS;CPPFLAGS;DEPENDS;SOURCES"
    "XFAIL"
    "CPPDEFS;CFLAGS;LDFLAGS;LIBS"
    "${ARGV}"
  )

  if (arg_CPPFLAGS)
    message("btest_add(): warning: CPPFLAGS is obsolete.  The argument is now called CPPDEFS.")
    list(APPEND PA_IGNORED "CPPDEFS" ${arg_CPPFLAGS})
  endif()

  if (NOT arg_NAME)
    if (NOT PA_OTHER)
      message(FATAL_ERROR "btest_add(): insufficiant arguments.  Need at least a name and a source or NAME and SOURCES.")
    else()
      list(GET PA_OTHER 0 arg_NAME)
      list(REMOVE_AT PA_OTHER 0)
    endif()
  endif()

  # because I'm too lazy to replace that varname :)
  set(name ${arg_NAME})

  # Get sources from SOURCES or PA_OTHER or error.
  if (arg_SOURCES)
    list(APPEND PA_IGNORED "SOURCES" ${arg_SOURCES})
  elseif (PA_OTHER)
    list(APPEND PA_IGNORED "SOURCES" ${PA_OTHER})
  else()
    message(FATAL_ERROR "btest_add(): need at least one source; use SOURCES.")
  endif()

  # message("${PA_IGNORED}")
  butil_add_executable(
    TARGET ${name}
    ${PA_IGNORED}
  )

  add_dependencies(${name} "setenvpath")

  if (arg_DEPENDS)
    # TODO: this won't exactly work.  I would need to do some hack with
    #       add_custom_command(APPEND I think)
    add_dependencies(${name} ${arg_DEPENDS})
  endif()

  set(test_name "test_${name}")
  # We rely that empty variables decay to nothing and that lists are expanded.
  # TODO:
  #   There is a slight hassle here.  If we want to link to a lib we just
  #   generated, there is no way to supply the linkdir just for only this
  #   function.
  add_test(
    ${test_name}
    ${BTEST_EMULATOR_PF} ${name}${CMAKE_EXECUTABLE_SUFFIX} ${arg_ARGS}
  )

  if (arg_XFAIL)
    set_tests_properties(
      ${test_name}
      PROPERTIES WILL_FAIL YES
    )
  endif()
endfunction()

# Test with ruby.
function(btest_add_ruby name ruby_input)
  set(args "${ARGV}")
  list(REMOVE_AT args 0 1)
  butil_parse_args(
    "GENERATOR_ARGS;SCRIPT_DEPENDS"
    ""
    "ARGS;CPPFLAGS;CPPDEFS;CFLAGS;LDFLAGS;LIBS;DEPENDS;XFAIL"
    "${args}"
  )

  if (PA_OTHER)
    message(FATAL_ERROR "btest_add_ruby(): too many arguments")
  endif()

  if (NOT BTEST_ADD_RUBY_DIR)
    message(FATAL_ERROR "btest_add_ruby(): BTEST_ADD_RUBY_DIR is not defined.")
  endif()

  # Note: expand for other languages maybe?
  set(script_out "${BTEST_ADD_RUBY_DIR}/${name}.cpp")

  # We have to depend on this because the directory changes every time we run
  # the generator which means all the scripts get regenerated twice.  It simply
  # says "we created the directory."
  set(ruby_dir_depend "${BTEST_ADD_RUBY_DIR}/btest_dir_stamp")
  # I do not know why, but it seems that this target must be added in the same function
  # as the stuff that depends on it.  Also, it doesn't seem to matter that we just created
  # a duplicate output here.  *Shrug*.
  add_custom_command(
    OUTPUT "${ruby_dir_depend}"
    COMMAND ${CMAKE_COMMAND} -E make_directory "${BTEST_ADD_RUBY_DIR}"
    WORKING_DIRECTORY "${CMAKE_BINARY_DIR}"
    COMMAND ${CMAKE_COMMAND} -E touch "${ruby_dir_depend}"
    WORKING_DIRECTORY "${CMAKE_BINARY_DIR}"
    COMMENT "Creating dir for ruby generated tests."
    VERBATIM
  )

  set_property(
    DIRECTORY APPEND
    PROPERTY "ADDITIONAL_MAKE_CLEAN_FILES"
    "${script_out}"
  )

  set(requires)
  set(require_expr "[\t ]*require[ \t]+['\"]([^\"']+)['\"]")
  file(
    STRINGS "${ruby_input}" requires
    REGEX "${require_expr}"
  )

  set(script_working_dir "${CMAKE_CURRENT_SOURCE_DIR}")
  set(required_depends)
  foreach(req ${requires})
    string(REGEX REPLACE "${require_expr}" "\\1" file "${req}")
    set(file "${script_working_dir}/${file}.rb")
    if (EXISTS "${file}")
      list(APPEND required_depends "${file}")
    endif()
  endforeach()

  add_custom_command(
    OUTPUT "${script_out}"
    COMMAND "${RUBY_EXE}" "-w" "${ruby_input}" ${arg_GENERATOR_ARGS} > ${script_out}
    WORKING_DIRECTORY "${script_working_dir}"
    DEPENDS "${ruby_input}"
            ${ruby_dir_depend}
            ${arg_SCRIPT_DEPENDS}
            ${required_depends}
    COMMENT "Ruby generating ${name} with args ${arg_GENERATOR_ARGS}"
    VERBATIM
  )

  btest_add(NAME "${name}" SOURCES "${script_out}" ${PA_IGNORED})
endfunction()

# Compile a test which is expected to fail to compile.
#
# btest_add_compile_fail(
#   name
#   source
#   [CFLAGS flag...]
# )
function(btest_add_compile_fail name source)
  butil_parse_args("CFLAGS" "" "" "${ARGV}")

  # Ideally I want to add this to add_test directly... then we can run it
  # under ctest...
  #
  # try_compile(
  #   result bindir srcfile
  #   [CMAKE_FLAGS <Flags>]
  #   [COMPILE_DEFINITIONS <flags> ...]
  #   [OUTPUT_VARIABLE var]
  #   [COPY_FILE <filename>]
  # )

  # if (result)
  #  error.
  # endif()

# TODO: this.
endfunction()
