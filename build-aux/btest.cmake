# Bunker's unit test functions.  See prototypes for help.  This file also sets 
# up some variables (see end).  This design is based on boost's cmake test 
# functions.
#
# These functions use wine to run tests on unix when cross-compiling for
# windows.
#
# Define the list variable BTEST_WINE_DLLPATHS to say where the dlls are for
# wine to searh for.  Otherwise you need to copy them to the test directories
# or configure wine to search for them using the PATH *from within wine*.


# Sets any marked variable to that of the varname.  Everything which is not 
# marked by a name (like VARNAME val1 ...) goes in a var called OTHER.  Only
# those vars in $allowed are searched for.
#
# Examples:
#
#   btest_parse_args("ARGS" "" "ARGS;x;y")
#   ARGS = x;y
#
#   btest_parse_args("ARGS;SRCS" "" "ARGS;x;y;SRCS;x;y;sdsdsd")
#   ARGS = x;y, SRCS = x;y;sdsdsd
#
#   btest_parse_args("ARGS;SRCS" "" "blah1;blah2;ARGS;x;y;SRCS;x;y;sdsdsd")
#   ARGS = x;y, SRCS = x;y;sdsdsd, OTHER = blah1;blah2
#
# The ignore parameter will cause markers to put stuff in he PA_OTHER into
# PA_IGNORED.
#
# TODO: write examples of the ignore list thing.  
# TODO: a simple unit test for this would be useful.
macro(btest_parse_args allowed ignore arglist)
  set(pa_var)
  set(pa_add "TRUE")
  foreach(arg ${arglist})
    # Set the varptr to the marker var if applicable.
    foreach (search_arg ${allowed})
      if (${arg} STREQUAL "${search_arg}")
        set(pa_var ${arg})
        set(pa_add)
        break()
      endif()
    endforeach()

    # Set the varptr to PA_IGNORED if applicable.
    foreach (search_arg ${ignore}) 
      if (${arg} STREQUAL ${search_arg})
        set(pa_var "PA_IGNORED")
        # Yes, we DO want this one!
        set(pa_add TRUE)
        break()
      endif()
    endforeach()

    # If this arg is not a marker var, then add it to the varptr.
    if (pa_add) 
      if (NOT pa_var) 
        list(APPEND "PA_OTHER" ${arg})
      else()
        list(APPEND ${pa_var} ${arg})
      endif()
    endif()

    set(pa_add "TRUE")
  endforeach()
endmacro()

# Make a test with the target name name_test.  Note that if you are depending 
# on a top level target, you should use add_dependencies on $name_test instead 
# of using DEPENDS -- that's just for files.
#
# Details:
#
# btest_add(
#   name
#   [source_list | SOURCES source...]
#   [ARGS arg... ]
#   [CPPFLAGS flag...]
#   [CFLAGS flag...]
#   [LDFLAGS flag...]
#   [LIBS link_name...]
#   [DEPENDS depend...]
#   [XFAIL TRUE|FALSE]
# )
#
# TODO: it would be much nicer if I had XFAIL as a flag, rather than a boolean.
function(btest_add)
  btest_parse_args("ARGS;CPPFLAGS;CFLAGS;LDFLAGS;LIBS;DEPENDS;SOURCES;XFAIL" "" "${ARGV}")

  if (NOT PA_OTHER)
    message(FATAL_ERROR "btest_add(): insufficiant arguments.  Need at least a name and a source.")
  endif()

  list(GET PA_OTHER 0 name)
  list(REMOVE_AT PA_OTHER 0)

  if (NOT SOURCES)
    if (NOT PA_OTHER) 
      message(FATAL_ERROR "btest_add(): need at least one source.")
    else()
      set(SOURCES ${PA_OTHER})
    endif()
  endif()

  add_executable(${name} ${SOURCES})

  if (LIBS)
    target_link_libraries(${name} ${LIBS})
  endif()

  if (CPPFLAGS) 
    set_property(
      TARGET ${name} APPEND PROPERTY
      COMPILE_DEFINITIONS ${CPPFLAGS}
    )
  endif()

  add_dependencies(${name} "setenvpath")

  if (DEPENDS)
    # TODO: don't know if this'll  work.
    add_dependencies(${name} ${DEPENDS})
  endif()

  if (LDFLAGS)
    set_property(
      TARGET ${name} APPEND PROPERTY LINK_FLAGS ${LDFLAGS}
    )
  endif()

  if (CFLAGS)
    set_property(
      TARGET ${name} APPEND PROPERTY COMPILE_FLAGS ${CFLAGS}
    )
  endif()

  set(test_name "test_${name}")
  # We rely that empty variables decay to nothing and that lists are expanded.
  add_test(
    ${test_name}
    ${BTEST_EMULATOR_PF} ${name}${CMAKE_EXECUTABLE_SUFFIX} ${ARGS}
  )

  if (XFAIL)
    set_tests_properties(
      ${test_target}
      PROPERTIES WILL_FAIL YES
    )
  endif()
endfunction()

# Add a test which is generated by ruby.  All params are as btest_add() except
# GENERATOR_ARGS which is given to the ruby_file as its arguments.  Tests are
# automatically placed in a subdirectory of the binary dir which is removed
# with make clean.  SCRIPT_DEPENDS is to add more dependencies to the ruby
# target.
#
# Details:
#
# btest_add_ruby(
#   name
#   ruby_input
#   [GENERATOR_ARGS arg...]
#   [ARGS arg...]
#   [CPPFLAGS flag...]
#   [CFLAGS flag...]
#   [LDFLAGS flag...]
#   [LIBS link_name...]
#   [DEPENDS depend...]
#   [SCRIPT_DEPENDS depend...]
#   [XFAIL TRUE|FALSE]
# )
function(btest_add_ruby name ruby_input)
  set(args "${ARGV}")
  list(REMOVE_AT args 0 1)
  btest_parse_args("GENERATOR_ARGS;SCRIPT_DEPENDS" "ARGS;CPPFLAGS;CFLAGS;LDFLAGS;LIBS;DEPENDS;SOURCES;XFAIL" "${args}")

  if (OTHER) 
    message(FATAL_ERROR "btest_add_ruby(): too many arguments")
  endif()


  set(dir "${CMAKE_BINARY_DIR}/ruby_tests")
  # Note: expand for other languages maybe?
  set(script_out "${dir}/${name}.cpp")

  # TODO: mkdir_p of ${dir} using cmake as a command somehow.  Also need to clean it, again
  # somehow.   This way it can be a rule which is rebuilt with make all instead of just breaking 
  # everything if it's not there.
  if (NOT IS_DIRECTORY "${dir}")
    file(MAKE_DIRECTORY "${dir}")

    set_property(
      DIRECTORY APPEND
      PROPERTY "ADDITIONAL_MAKE_CLEAN_FILES"
      "${dir}"
    )
  endif()

  add_custom_command(
    OUTPUT "${script_out}"
    COMMAND "${RUBY_EXE}" "-w" "${ruby_input}" ${GENERATOR_ARGS} > ${script_out}
    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
    DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/${script}" ${SCRIPT_DEPENDS}
    COMMENT "Ruby generating ${name} with args ${GENERATOR_ARGS}"
    VERBATIM
  )

  btest_add("${name}" "${script_out}" ${PA_OTHER} ${PA_IGNORED})
endfunction()

# Compile a test which is expected to fail to compile.
# 
# btest_add_compile_fail(
#   name
#   source
#   [CFLAGS flag...]
# )
function(btest_add_compile_fail)
# TODO: this.
endfunction()

if (WIN32 AND CMAKE_CROSSCOMPILING AND CMAKE_HOST_UNIX)
  find_program(WINE_EXE wine)
  mark_as_advanced(WINE_EXE)
  if (WINE_EXE) 
    message(STATUS "Wine will be used for cross-compiled unit tests: ${WINE_EXE}")
  else()
    message(STATUS "Wine cannot be found.  Unit tests may fail.")
  endif()

  set(
    BTEST_WINE_DLLPATHS "" CACHE STRING
    "Extra paths (seperate with semic) where dlls for wine are - rpath hack, basically."
  )
  mark_as_advanced(BTEST_WINE_DLLPATHS)

  set(btest_envpath_bin "setenvpath")
  add_executable(${btest_envpath_bin} "${CMAKE_SOURCE_DIR}/build-aux/setenvpath.c")

  set(btest_envpath_exe ${CMAKE_BINARY_DIR}/${btest_envpath_bin}${CMAKE_EXECUTABLE_SUFFIX})

  foreach (dir ${BTEST_WINE_DLLPATHS})
    if (NOT IS_DIRECTORY ${dir})
      message(FATAL_ERROR "Directory in BTEST_WINE_DLLPATHS does not exist: ${dir}")
    endif()

    list(APPEND btest_envpath_args "-p")
    list(APPEND btest_envpath_args "${dir}")
  endforeach()

  # Finally set the prefix we will use to run test, and the extra 
  # dependancy for every test.
  if (BTEST_WINE_DLLPATHS) 
    set(BTEST_EMULATOR_PF    "${WINE_EXE};${btest_envpath_exe};${btest_envpath_args}")
  else()
    set(BTEST_EMULATOR_PF    "${WINE_EXE}")
  endif()
endif()

find_program(RUBY_EXE ruby)
if (NOT RUBY_EXE)
  find_program(RUBY_EXE ruby1.8)
endif()
